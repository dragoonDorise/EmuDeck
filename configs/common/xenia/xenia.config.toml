[APU]
apu = "any"                                       	# Audio system. Use: [any, nop, sdl, xaudio2]
ffmpeg_verbose = false                            	# Verbose FFmpeg output (debug and above)
mute = false                                      	# Mutes all audio output.


[CPU]
break_condition_gpr = -1                          	# GPR compared to
break_condition_op = "eq"                         	# comparison operator
break_condition_truncate = true                   	# truncate value to 32-bits
break_condition_value = 0                         	# value compared against
break_on_debugbreak = true                        	# int3 on JITed __debugbreak requests.
break_on_instruction = 0                          	# int3 before the given guest address is executed.
break_on_start = false                            	# Break into the debugger on startup.
break_on_unimplemented_instructions = true        	# Break to the host debugger (or crash if no debugger attached) if an unimplemented PowerPC instruction is encountered.
clock_no_scaling = false                          	# Disable scaling code. Time management and locking is bypassed. Guest system time is directly pulled from host.
clock_source_raw = false                          	# Use the RDTSC instruction as the time source. Host CPU must support invariant TSC.
cpu = "any"                                       	# CPU backend [any, x64].
debug_symbol_loader = false                       	# Enable dbghelp debug logging and validation.
debugprint_trap_log = false                       	# Log debugprint traps to the active debugger
disable_global_lock = false                       	# Disables global lock usage in guest code. Does not affect host code.
disassemble_functions = false                     	# Disassemble functions during generation.
emit_source_annotations = false                   	# Add extra movs and nops to make disassembly easier to read.
ignore_undefined_externs = true                   	# Don't exit when an undefined extern is called.
inline_mmio_access = true                         	# Inline constant MMIO loads and stores.
load_module_map = ""                              	# Loads a .map for symbol names and to diff with the generated symbol database.
pvr = 7407360                                     	# Processor version and revision number.
													  # Bits 0 to 15 are the version number.
													  # Bits 16 to 31 are the revision number.
													  # Note: Some XEXs (such as mfgbootlauncher.xex) may check for a value that's less than 0x710700.

store_all_context_values = false                  	# Don't strip dead context stores to aid in debugging.
trace_function_coverage = false                   	# Generate tracing for function instruction coverage statistics.
trace_function_data = false                       	# Generate tracing for function result data.
trace_function_data_path = ""                     	# File to write trace data to.
trace_function_references = false                 	# Generate tracing for function address references.
trace_functions = false                           	# Generate tracing for function statistics.
validate_hir = false                              	# Perform validation checks on the HIR during compilation.


[Config]
defaults_date = 2020123113                        	# Do not modify - internal version of the default values in the config, for seamless updates if default value of any option is changed.


[Content]
license_mask = 0                                  	# Set license mask for activated content.
													  #  0 = No licenses enabled.
													  #  1 = First license enabled. Generally the full version license in
													  #      Xbox Live Arcade titles.
													  #  -1 or 0xFFFFFFFF = All possible licenses enabled. Generally a
													  #                     bad idea, could lead to undefined behavior.


[D3D12]
d3d12_adapter = -1                                	# Index of the DXGI adapter to use. -1 for any physical adapter, -2 for WARP software rendering.
d3d12_allow_variable_refresh_rate_and_tearing = true	# In fullscreen, allow using variable refresh rate on displays supporting it. On displays not supporting VRR, screen tearing may occur in certain cases.
d3d12_bindless = true                             	# Use bindless resources where available - may improve performance, but may make debugging more complicated.
d3d12_break_on_error = false                      	# Break on Direct3D 12 validation errors.
d3d12_break_on_warning = false                    	# Break on Direct3D 12 validation warnings.
d3d12_debug = false                               	# Enable Direct3D 12 and DXGI debug layer.
d3d12_dxbc_disasm = false                         	# Disassemble DXBC shaders after generation.
d3d12_dxbc_disasm_dxilconv = false                	# Disassemble DXBC shaders after conversion to DXIL, if DXIL shaders are supported by the OS, and DirectX Shader Compiler DLLs available at https://github.com/microsoft/DirectXShaderCompiler/releases are present.
d3d12_pipeline_creation_threads = -1              	# Number of threads used for graphics pipeline creation. -1 to calculate automatically (75% of logical CPU cores), a positive number to specify the number of threads explicitly (up to the number of logical CPU cores), 0 to disable multithreaded pipeline creation.
d3d12_queue_priority = 1                          	# Graphics (direct) command queue scheduling priority, 0 - normal, 1 - high, 2 - global realtime (requires administrator privileges, may impact system responsibility)
d3d12_readback_memexport = false                  	# Read data written by memory export in shaders on the CPU. This may be needed in some games (but many only access exported data on the GPU, and this flag isn't needed to handle such behavior), but causes mid-frame synchronization, so it has a huge performance impact.
d3d12_readback_resolve = false                    	# Read render-to-texture results on the CPU. This may be needed in some games, for instance, for screenshots in saved games, but causes mid-frame synchronization, so it has a huge performance impact.
d3d12_submit_on_primary_buffer_end = true         	# Submit the command list when a PM4 primary buffer ends if it's possible to submit immediately to try to reduce frame latency.
d3d12_tessellation_wireframe = false              	# Display tessellated surfaces as wireframe for debugging.
d3d12_tiled_shared_memory = true                  	# Enable tiled resources for shared memory emulation. Disabling them increases video memory usage - a 512 MB buffer is created - but allows graphics debuggers that don't support tiled resources to work.


[Display]
fullscreen = false                                	# Whether to launch the emulator in fullscreen.
host_present_from_non_ui_thread = true            	# Allow the GPU emulation thread to present the guest output to the host surface directly instead of requesting the UI thread to do so through the host window system.
postprocess_antialiasing = ""                     	# Post-processing anti-aliasing effect to apply to the image output of the game.
													  # Using post-process anti-aliasing is heavily recommended when AMD FidelityFX Contrast Adaptive Sharpening or Super Resolution 1.0 is active.
													  # Use: [none, fxaa, fxaa_extreme]
													  #  none (or any value not listed here):
													  #   Don't alter the original image.
													  #  fxaa:
													  #   NVIDIA Fast Approximate Anti-Aliasing 3.11, normal quality preset (12).
													  #  fxaa_extreme:
													  #   NVIDIA Fast Approximate Anti-Aliasing 3.11, extreme quality preset (39).

postprocess_dither = true                         	# Dither the final image output from the internal precision to 8 bits per channel so gradients are smoother.
													  # On a 10bpc display, the lower 2 bits will still be kept, but noise will be added to them - disabling may be recommended for 10bpc, but it depends on the 10bpc displaying capabilities of the actual display used.

postprocess_ffx_cas_additional_sharpness = 0.0    	# Additional sharpness for AMD FidelityFX Contrast Adaptive Sharpening (CAS), from 0 to 1.
													  # Higher is sharper.

postprocess_ffx_fsr_max_upsampling_passes = 4     	# Maximum number of upsampling passes performed in AMD FidelityFX Super Resolution 1.0 (FSR) before falling back to bilinear stretching after the final pass.
													  # Each pass upscales only to up to 2x2 the previous size. If the game outputs a 1280x720 image, 1 pass will upscale it to up to 2560x1440 (below 4K), after 2 passes it will be upscaled to a maximum of 5120x2880 (including 3840x2160 for 4K), and so on.
													  # This variable has no effect if the display resolution isn't very high, but may be reduced on resolutions like 4K or 8K in case the performance impact of multiple FSR upsampling passes is too high, or if softer edges are desired.
													  # The default value is the maximum internally supported by Xenia.

postprocess_ffx_fsr_sharpness_reduction = 0.20000000298023224	# Sharpness reduction for AMD FidelityFX Super Resolution 1.0 (FSR), in stops.
													  # Lower is sharper.

postprocess_scaling_and_sharpening = ""           	# Post-processing effect to use for resampling and/or sharpening of the final display output.
													  # Use: [bilinear, cas, fsr]
													  #  bilinear (or any value not listed here):
													  #   Original image at 1:1, simple bilinear stretching for resampling.
													  #  cas:
													  #   Use AMD FidelityFX Contrast Adaptive Sharpening (CAS) for sharpening at scaling factors of up to 2x2, with additional bilinear stretching for larger factors.
													  #  fsr:
													  #   Use AMD FidelityFX Super Resolution 1.0 (FSR) for highest-quality upscaling, or AMD FidelityFX Contrast Adaptive Sharpening for sharpening while not scaling or downsampling.
													  #   For scaling by factors of more than 2x2, multiple FSR passes are done.

present_letterbox = true                          	# Maintain aspect ratio when stretching by displaying bars around the image when there's no more overscan area to crop out.
present_render_pass_clear = true                  	# On graphics backends where this is supported, use the clear render pass load operation in presentation instead of clear commands clearing only the letterbox area.
present_safe_area_x = 90                          	# Percentage of the image width that can be kept when presenting to maintain aspect ratio without letterboxing or stretching.
present_safe_area_y = 90                          	# Percentage of the image height that can be kept when presenting to maintain aspect ratio without letterboxing or stretching.


[GPU]
depth_float24_conversion = ""                     	# Method for converting 32-bit Z values to 20e4 floating point when using host depth buffers without native 20e4 support (when not using rasterizer-ordered views / fragment shader interlocks to perform depth testing manually).
													  # Use: [any, on_copy, truncate, round]
													  #  on_copy:
													  #   Do depth testing at host precision, converting when copying between color and depth buffers (or between depth buffers of different formats) to support reinterpretation, but keeps the last host depth buffer used for each EDRAM range and reloads the host precision value if it's still up to date after the EDRAM range was used with a different pixel format.
													  #   + Highest performance, allows early depth test and writing.
													  #   + Host MSAA is possible with pixel-rate shading where supported.
													  #   - EDRAM > RAM > EDRAM depth buffer round trip done in certain games destroys precision irreparably, causing artifacts if another rendering pass is done after the EDRAM reupload.
													  #  truncate:
													  #   Convert to 20e4 directly in pixel shaders, always rounding down.
													  #   + Average performance, conservative early depth test is possible.
													  #   + No precision loss when anything changes in the storage of the depth buffer, EDRAM > RAM > EDRAM copying preserves precision.
													  #   - Rounding mode is incorrect, sometimes giving results smaller than they should be - may cause inaccuracy especially in edge cases when the game wants to write an exact value.
													  #   - Host MSAA is only possible at SSAA speed, with per-sample shading.
													  #  round:
													  #   Convert to 20e4 directly in pixel shaders, correctly rounding to the nearest even.
													  #   + Highest accuracy.
													  #   - Significantly limited performance, early depth test is not possible.
													  #   - Host MSAA is only possible at SSAA speed, with per-sample shading.
													  #  Any other value:
													  #   Choose what is considered the most optimal (currently "on_copy").

depth_transfer_not_equal_test = true              	# When transferring data between depth render targets, use the "not equal" test to avoid writing rewriting depth via shader depth output if it's the same as the one currently in the depth buffer in case of round trips of the data.
													  # Settings this to true may make transfer round trips more friendly to depth compression depending on how the GPU implements it (as arbitrary depth output may result in it being disabled completely), which is beneficial to subsequent rendering, while setting this to false may reduce bandwidth usage during transfers as the previous depth won't need to be read.

draw_resolution_scale_x = 1                       	# Integer pixel width scale used for scaling the rendering resolution opaquely to the game.
													  # 1, 2 and 3 may be supported, but support of anything above 1 depends on the device properties, such as whether it supports sparse binding / tiled resources, the number of virtual address bits per resource, and other factors.
													  # Various effects and parts of game rendering pipelines may work incorrectly as pixels become ambiguous from the game's perspective and because half-pixel offset (which normally doesn't affect coverage when MSAA isn't used) becomes full-pixel.

draw_resolution_scale_y = 1                       	# Integer pixel width scale used for scaling the rendering resolution opaquely to the game.
													  # See draw_resolution_scale_x for more information.

draw_resolution_scaled_texture_offsets = true     	# Apply offsets from texture fetch instructions taking resolution scale into account for render-to-texture, for more correct shadow filtering, bloom, etc., in some cases.
dump_shaders = ""                                 	# For shader debugging, path to dump GPU shaders to as they are compiled.
dxbc_source_map = false                           	# Disassemble Xenos instructions as comments in the resulting DXBC for debugging.
dxbc_switch = true                                	# Use switch rather than if for flow control. Turning this off or on may improve stability, though this heavily depends on the driver - on AMD, it's recommended to have this set to true, as some titles appear to crash when if is used for flow control (possibly the shader compiler tries to flatten them). On Intel HD Graphics, this is ignored because of a crash with the switch instruction.
execute_unclipped_draw_vs_on_cpu = true           	# Execute the vertex shader for draws with clipping disabled, primarily screen-space draws (such as clears), on the CPU when possible to estimate the extent of the EDRAM involved in the draw.
													  # Enabling this may significantly improve GPU performance as otherwise up to the entire EDRAM may be considered used in draws without clipping, potentially resulting in spurious EDRAM range ownership transfer round trips between host render targets.
													  # Also, on hosts where certain render target formats have to be emulated in a lossy way (for instance, 16-bit fixed-point via 16-bit floating-point), this prevents corruption of other render targets located after the current ones in the EDRAM by lossy range ownership transfers done for those draws.

execute_unclipped_draw_vs_on_cpu_for_psi_render_backend = true	# If execute_unclipped_draw_vs_on_cpu is enabled, execute the vertex shader for unclipped draws on the CPU even when using the pixel shader interlock (rasterizer-ordered view) implementation of the render backend on the host, for which no expensive copying between host render targets is needed when the ownership of a EDRAM range is changed.
													  # If this is enabled, excessive barriers may be eliminated when switching between different render targets in separate EDRAM locations.

execute_unclipped_draw_vs_on_cpu_with_scissor = false	# Don't restrict the usage of execute_unclipped_draw_vs_on_cpu to only non-scissored draws (with the right and the bottom sides of the scissor rectangle at 8192 or beyond) even though if the scissor rectangle is present, it's usually sufficient for esimating the height of the render target.
													  # Enabling this may cause excessive processing of vertices on the CPU, as some games draw rectangles (for their UI, for instance) without clipping, but with a proper scissor rectangle.

force_convert_line_loops_to_strips = false        	# For host graphics API downlevel support testing only, force CPU conversion of line loops to line strips even if the host supports line loop primitives natively.
force_convert_quad_lists_to_triangle_lists = false	# For host graphics API downlevel support testing only, force CPU conversion of quad lists to quad strips even if the host supports quad list primitives natively or via geometry shader emulation.
													  # May also be useful for graphics debugging when the debugger doesn't display the geometry generated by geometry shaders properly.

force_convert_triangle_fans_to_lists = false      	# For host graphics API downlevel support testing only, force CPU conversion of triangle fans to triangle lists even if the host supports triangle fan primitives natively.
gamma_render_target_as_srgb = false               	# When the host can't write piecewise linear gamma directly with correct blending, use sRGB output on the host for conceptually correct blending in linear color space while having slightly different precision distribution in the render target and severely incorrect values if the game accesses the resulting colors directly as raw data.
gpu = "vulkan"                                       	# Graphics system. Use: [any, d3d12, vulkan, null]
gpu_allow_invalid_fetch_constants = false         	# Allow texture and vertex fetch constants with invalid type - generally unsafe because the constant may contain completely invalid values, but may be used to bypass fetch constant type errors in certain games until the real reason why they're invalid is found.
half_pixel_offset = true                          	# Enable support of vertex half-pixel offset (D3D9 PA_SU_VTX_CNTL PIX_CENTER). Generally games are aware of the half-pixel offset, and having this enabled is the correct behavior (disabling this may significantly break post-processing in some games), but in certain games it might have been ignored, resulting in slight blurriness of UI textures, for instance, when they are read between texels rather than at texel centers, or the leftmost/topmost pixels may not be fully covered when MSAA is used with fullscreen passes.
ignore_32bit_vertex_index_support = false         	# For host graphics API downlevel testing only (useful only for Qualcomm Adreno 4xx-level host GPU testing), force indirection or pre-masking and pre-swapping of 32-bit vertex indices as if the host only supports 24-bit indices.
mrt_edram_used_range_clamp_to_min = true          	# With host render targets, if multiple render targets are bound, estimate the EDRAM range modified in any of them to be not bigger than the distance between any two render targets in the EDRAM, rather than allowing the last one claim the rest of the EDRAM.
													  # Has effect primarily on draws without viewport clipping.
													  # Setting this to false results in higher accuracy in rare cases, but may increase the amount of copying that needs to be done sometimes.

native_2x_msaa = true                             	# Use host 2x MSAA when available. Can be disabled for scalability testing on host GPU APIs where 2x is not mandatory, in this case, 2 samples of 4x MSAA will be used instead (with similar or worse quality and higher memory usage).
native_stencil_value_output = true                	# Use pixel shader stencil reference output where available for purposes like copying between render targets. Can be disabled for scalability testing, in this case, much more expensive drawing of 8 quads will be done.
native_stencil_value_output_d3d12_intel = false   	# Allow stencil reference output usage on Direct3D 12 on Intel GPUs - not working on UHD Graphics 630 as of March 2021 (driver 27.20.0100.8336).
primitive_processor_cache_min_indices = 4096      	# Smallest number of guest indices to store in the cache to try reusing later in the same frame if processing (such as primitive type conversion or reset index replacement) is performed.
													  # Setting this to a very high value may result in excessive CPU processing, while a very low value may result in excessive locking and lookups.
													  # Negative values disable caching.

query_occlusion_fake_sample_count = 1000          	# If set to -1 no sample counts are written, games may hang. Else, the sample count of every tile will be incremented on every EVENT_WRITE_ZPD by this number. Setting this to 0 means everything is reported as occluded.
render_target_path_d3d12 = ""                     	# Render target emulation path to use on Direct3D 12.
													  # Use: [any, rtv, rov]
													  #  rtv:
													  #   Host render targets and fixed-function blending and depth / stencil testing, copying between render targets when needed.
													  #   Lower accuracy (limited pixel format support).
													  #   Performance limited primarily by render target layout changes requiring copying, but generally higher.
													  #  rov:
													  #   Manual pixel packing, blending and depth / stencil testing, with free render target layout changes.
													  #   Requires a GPU supporting rasterizer-ordered views.
													  #   Highest accuracy (all pixel formats handled in software).
													  #   Performance limited primarily by overdraw.
													  #   On AMD drivers, currently causes shader compiler crashes in many cases.
													  #  Any other value:
													  #   Choose what is considered the most optimal for the system (currently always RTV because the ROV path is much slower now, except for Intel GPUs, which have a bug in stencil testing that causes Xbox 360 Direct3D 9 clears not to work).

resolve_resolution_scale_duplicate_second_pixel = true	# When using resolution scale, apply the hack that duplicates the right/lower host pixel in the left and top sides of render target resolve areas to eliminate the gap caused by half-pixel offset (this is necessary for certain games to display the scene graphics).
snorm16_render_target_full_range = true           	# When the host can only support 16_16 and 16_16_16_16 render targets as -1...1, remap -32...32 to -1...1 to use the full possible range of values, at the expense of multiplicative blending correctness.
spv_disasm = false                                	# Disassemble SPIR-V shaders after generation
spv_validate = false                              	# Validate SPIR-V shaders after generation
store_shaders = true                              	# Store shaders persistently and load them when loading games to avoid runtime spikes and freezes when playing the game not for the first time.
texture_cache_memory_limit_hard = 768             	# Maximum host texture memory usage (in megabytes) above which textures will be destroyed as soon as possible.
texture_cache_memory_limit_render_to_texture = 24 	# Part of the host texture memory budget (in megabytes) that will be scaled by the current drawing resolution scale.
													  # If texture_cache_memory_limit_soft, for instance, is 384, and this is 24, it will be assumed that the game will be using roughly 24 MB of render-to-texture (resolve) targets and 384 - 24 = 360 MB of regular textures - so with 2x2 resolution scaling, the soft limit will be 360 + 96 MB, and with 3x3, it will be 360 + 216 MB.

texture_cache_memory_limit_soft = 384             	# Maximum host texture memory usage (in megabytes) above which old textures will be destroyed.
texture_cache_memory_limit_soft_lifetime = 30     	# Seconds a texture should be unused to be considered old enough to be deleted if texture memory usage exceeds texture_cache_memory_limit_soft.
texture_dump = false                              	# Dump textures to DDS
trace_gpu_prefix = "scratch/gpu/"                 	# Prefix path for GPU trace files.
trace_gpu_stream = false                          	# Trace all GPU packets.
vsync = true                                      	# Enable VSYNC.


[General]
debug = false                                     	# Allow debugging and retain debug information.
discord = true                                    	# Enable Discord rich presence
enable_console = false                            	# Open a console window with the main window
launch_module = ""                                	# Executable to launch from the .iso or the package instead of default.xex or the module specified by the game. Leave blank to launch the default module.
time_scalar = 1.0                                 	# Scalar used to speed or slow time (1x, 2x, 1/2x, etc).


[HID]
guide_button = false                              	# Forward guide button presses to guest.
hid = "any"                                       	# Input system. Use: [any, nop, sdl, winkey, xinput]


[HID.WinKey]
keybind_a = "0xBA"                                	# List of keys to bind to A, separated by spaces
keybind_b = "0xDE"                                	# List of keys to bind to B, separated by spaces
keybind_back = "Z"                                	# List of keys to bind to BACK, separated by spaces
keybind_dpad_down = "^S"                          	# List of keys to bind to DPAD_DOWN, separated by spaces
keybind_dpad_left = "^A"                          	# List of keys to bind to DPAD_LEFT, separated by spaces
keybind_dpad_right = "^D"                         	# List of keys to bind to DPAD_RIGHT, separated by spaces
keybind_dpad_up = "^W"                            	# List of keys to bind to DPAD_UP, separated by spaces
keybind_left_shoulder = "1"                       	# List of keys to bind to LEFT_SHOULDER, separated by spaces
keybind_left_thumb = "F"                          	# List of keys to bind to LEFT_THUMB_PRESSED, separated by spaces
keybind_left_thumb_down = "_S"                    	# List of keys to bind to LEFT_THUMB_DOWN, separated by spaces
keybind_left_thumb_left = "_A"                    	# List of keys to bind to LEFT_THUMB_LEFT, separated by spaces
keybind_left_thumb_right = "_D"                   	# List of keys to bind to LEFT_THUMB_RIGHT, separated by spaces
keybind_left_thumb_up = "_W"                      	# List of keys to bind to LEFT_THUMB_UP, separated by spaces
keybind_left_trigger = "Q I"                      	# List of keys to bind to LEFT_TRIGGER, separated by spaces
keybind_right_shoulder = "3"                      	# List of keys to bind to RIGHT_SHOULDER, separated by spaces
keybind_right_thumb = "K"                         	# List of keys to bind to RIGHT_THUMB_PRESSED, separated by spaces
keybind_right_thumb_down = "0x28"                 	# List of keys to bind to RIGHT_THUMB_DOWN, separated by spaces
keybind_right_thumb_left = "0x25"                 	# List of keys to bind to RIGHT_THUMB_LEFT, separated by spaces
keybind_right_thumb_right = "0x27"                	# List of keys to bind to RIGHT_THUMB_RIGHT, separated by spaces
keybind_right_thumb_up = "0x26"                   	# List of keys to bind to RIGHT_THUMB_UP, separated by spaces
keybind_right_trigger = "E O"                     	# List of keys to bind to RIGHT_TRIGGER, separated by spaces
keybind_start = "X"                               	# List of keys to bind to START, separated by spaces
keybind_x = "L"                                   	# List of keys to bind to X, separated by spaces
keybind_y = "P"                                   	# List of keys to bind to Y, separated by spaces


[Kernel]
cl = ""                                           	# Specify additional command-line provided to guest.
ignore_thread_affinities = true                   	# Ignores game-specified thread affinities.
ignore_thread_priorities = true                   	# Ignores game-specified thread priorities.
kernel_cert_monitor = false                       	# Enable cert monitor.
kernel_debug_monitor = false                      	# Enable debug monitor.
kernel_display_gamma_power = 2.22222233           	# Display gamma to use with kernel_display_gamma_type 3.
kernel_display_gamma_type = 2                     	# Display gamma type: 0 - linear, 1 - sRGB (CRT), 2 - BT.709 (HDTV), 3 - power specified via kernel_display_gamma_power.
kernel_pix = false                                	# Enable PIX.
log_high_frequency_kernel_calls = false           	# Log kernel calls with the kHighFrequency tag.
xex_apply_patches = true                          	# Apply XEX patches.


[Logging]
flush_log = true                                  	# Flush log file after each log line batch.
log_file = ""                                     	# Logs are written to the given file
log_level = 2                                     	# Maximum level to be logged. (0=error, 1=warning, 2=info, 3=debug)
log_string_format_kernel_calls = false            	# Log kernel calls with the kHighFrequency tag.
log_to_debugprint = false                         	# Dump the log to DebugPrint.
log_to_stdout = true                              	# Write log output to stdout


[Memory]
protect_on_release = false                        	# Protect released memory to prevent accesses.
protect_zero = true                               	# Protect the zero page from reads and writes.
scribble_heap = false                             	# Scribble 0xCD into all allocated heap memory.
writable_executable_memory = true                 	# Allow mapping memory with both write and execute access, for simulating behavior on platforms where that's not supported


[SDL]
mappings_file = "gamecontrollerdb.txt"            	# Filename of a database with custom game controller mappings.


[Storage]
cache_root = ""                                   	# Root path for files used to speed up certain parts of the emulator or the game. These files may be persistent, but they can be deleted without major side effects such as progress loss. If empty, the cache folder under the storage root, or, if available, the cache directory preferred for the OS, will be used.
content_root = ""                                 	# Root path for guest content storage (saves, etc.), or empty to use the content folder under the storage root.
mount_cache = false                               	# Enable cache mount
mount_scratch = false                             	# Enable scratch mount
storage_root = ""                                 	# Root path for persistent internal data storage (config, etc.), or empty to use the path preferred for the OS, such as the documents folder, or the emulator executable directory if portable.txt is present in it.


[UI]
headless = false                                  	# Don't display any UI, using defaults for prompts as needed.
imgui_debug = false                               	# Show ImGui debugging tools.
profiler_dpi_scaling = false                      	# Apply window DPI scaling to the profiler.
show_profiler = false                             	# Show profiling UI by default.


[Vulkan]
vulkan_allow_present_mode_fifo_relaxed = true     	# When available, allow the relaxed first-in-first-out presentation mode (3rd priority), which causes waiting for host display vertical sync, but may present with tearing if frames don't meet the host display refresh rate.
vulkan_allow_present_mode_immediate = true        	# When available, allow the immediate presentation mode (1st priority), offering the lowest latency with the possibility of tearing in certain cases, and, depending on the configuration, variable refresh rate.
vulkan_allow_present_mode_mailbox = true          	# When available, allow the mailbox presentation mode (2nd priority), offering low latency without the possibility of tearing.
vulkan_debug_utils_messenger = false              	# Enable writing Vulkan debug messages via VK_EXT_debug_utils to the Xenia log.
vulkan_debug_utils_messenger_severity = 2         	# Maximum severity of messages to log via the Vulkan debug messenger: 0 - error, 1 - warning, 2 - info, 3 - verbose.
vulkan_debug_utils_names = false                  	# Enable naming Vulkan objects via VK_EXT_debug_utils.
vulkan_device = -1                                	# Index of the physical device to use, or -1 for any compatible device.
vulkan_dump_disasm = false                        	# Dump shader disassembly. NVIDIA only supported.
vulkan_native_msaa = false                        	# Use native MSAA
vulkan_renderdoc_capture_all = false              	# Capture everything with RenderDoc.
vulkan_validation = true                          	# Enable Vulkan validation (VK_LAYER_KHRONOS_validation). Messages will be written to the OS debug log without vulkan_debug_messenger or to the Xenia log with it.


[Win32]
win32_high_resolution_timer = true                	# Requests high-resolution timer from the NT kernel
win32_mmcss = true                                	# Opt in the Multimedia Class Scheduler Service (MMCSS) scheduling for prioritized access to CPU resources


[XConfig]
user_country = 103                                	# User country ID.
													  #    1=AE   2=AL   3=AM   4=AR   5=AT   6=AU   7=AZ   8=BE   9=BG
													  #   10=BH  11=BN  12=BO  13=BR  14=BY  15=BZ  16=CA  18=CH  19=CL
													  #   20=CN  21=CO  22=CR  23=CZ  24=DE  25=DK  26=DO  27=DZ  28=EC
													  #   29=EE  30=EG  31=ES  32=FI  33=FO  34=FR  35=GB  36=GE  37=GR
													  #   38=GT  39=HK  40=HN  41=HR  42=HU  43=ID  44=IE  45=IL  46=IN
													  #   47=IQ  48=IR  49=IS  50=IT  51=JM  52=JO  53=JP  54=KE  55=KG
													  #   56=KR  57=KW  58=KZ  59=LB  60=LI  61=LT  62=LU  63=LV  64=LY
													  #   65=MA  66=MC  67=MK  68=MN  69=MO  70=MV  71=MX  72=MY  73=NI
													  #   74=NL  75=NO  76=NZ  77=OM  78=PA  79=PE  80=PH  81=PK  82=PL
													  #   83=PR  84=PT  85=PY  86=QA  87=RO  88=RU  89=SA  90=SE  91=SG
													  #   92=SI  93=SK  95=SV  96=SY  97=TH  98=TN  99=TR 100=TT 101=TW
													  #  102=UA 103=US 104=UY 105=UZ 106=VE 107=VN 108=YE 109=ZA

user_language = 1                                 	# User language ID.
													  #   1=en  2=ja  3=de  4=fr  5=es  6=it  7=ko  8=zh
													  #   9=pt 11=pl 12=ru 13=sv 14=tr 15=nb 16=nl 17=zh


[x64]
x64_extension_mask = -1                           	# Allow the detection and utilization of specific instruction set features.
													  #     0 = x86_64 + AVX1
													  #     1 = AVX2
													  #     2 = FMA
													  #     4 = LZCNT
													  #     8 = BMI1
													  #    16 = BMI2
													  #    32 = F16C
													  #    64 = Movbe
													  #   128 = GFNI
													  #   256 = AVX512F
													  #   512 = AVX512VL
													  #  1024 = AVX512BW
													  #  2048 = AVX512DQ
													  #    -1 = Detect and utilize all possible processor features
